name: CI
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build-test:
    name: Build & Test (${{ matrix.os }})
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            triplet: linux-amd64
            install: sudo apt-get update && sudo apt-get install -y protobuf-compiler libprotobuf-dev cmake g++ ninja-build
            generator_opts: ""
          - os: windows-latest
            triplet: windows-amd64
            install: choco install -y protoc cmake ninja || powershell -Command "echo skipping"
            generator_opts: "-G Ninja"
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
      - name: Setup ccache (Unix)
        if: runner.os != 'Windows'
        uses: actions/cache@v4
        with:
          path: ~/.cache/ccache
          key: ccache-${{ runner.os }}-${{ matrix.triplet }}-${{ hashFiles('**/CMakeLists.txt', 'proto/**/*.proto') }}
          restore-keys: |
            ccache-${{ runner.os }}-${{ matrix.triplet }}-
      - name: Install deps
        run: ${{ matrix.install }}
      - name: Install protobuf via vcpkg (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $vcpkgRoot = "$env:USERPROFILE\vcpkg"
          if (-not (Test-Path $vcpkgRoot)) { git clone https://github.com/microsoft/vcpkg $vcpkgRoot }
          & "$vcpkgRoot\bootstrap-vcpkg.bat" -disableMetrics
          & "$vcpkgRoot\vcpkg.exe" install protobuf:x64-windows
          echo "VCPKG_TOOLCHAIN_FILE=$vcpkgRoot\scripts\buildsystems\vcpkg.cmake" >> $env:GITHUB_ENV
      - name: Configure ccache env (Unix)
        if: runner.os != 'Windows'
        run: |
          which ccache || sudo apt-get install -y ccache || true
          echo "CMAKE_CXX_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV
          echo "CMAKE_C_COMPILER_LAUNCHER=ccache" >> $GITHUB_ENV
      - name: Configure (Unix)
        if: runner.os != 'Windows'
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DT2D_BUILD_TESTS=ON -DT2D_BUILD_CLIENT=ON -DCMAKE_CXX_FLAGS_RELEASE="-O2 -g0" -DCMAKE_C_FLAGS_RELEASE="-O2 -g0" ${{ matrix.generator_opts }}
      - name: Configure (Windows)
        if: runner.os == 'Windows'
        shell: powershell
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DT2D_BUILD_TESTS=ON -DT2D_BUILD_CLIENT=ON -DCMAKE_CXX_FLAGS_RELEASE="-O2 -g0" -DCMAKE_C_FLAGS_RELEASE="-O2 -g0" -DCMAKE_TOOLCHAIN_FILE=$Env:VCPKG_TOOLCHAIN_FILE ${{ matrix.generator_opts }}
      - name: Build
        env:
          CMAKE_BUILD_PARALLEL_LEVEL: 4
        run: |
          echo "Limiting parallel build to $CMAKE_BUILD_PARALLEL_LEVEL jobs to reduce memory usage"
          cmake --build build -- -j$CMAKE_BUILD_PARALLEL_LEVEL
      - name: Run tests
        working-directory: build
        run: ctest --output-on-failure -T Test
      - name: Format check (Linux only)
        if: runner.os == 'Linux'
        run: bash scripts/format_check.sh || (echo "Run formatting target locally" && exit 1)
      - name: Upload server binary
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: t2d_server-${{ matrix.triplet }}
          path: build/t2d_server*
          if-no-files-found: warn
      - name: Upload desktop client prototype
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: t2d_desktop_client-${{ matrix.triplet }}
          path: build/t2d_desktop_client*
          if-no-files-found: warn
      - name: Package server (Linux only)
        if: runner.os == 'Linux'
        run: |
          bash scripts/package_server.sh
          ls -l dist
      - name: Upload server package (Linux only)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: t2d_server_package-${{ matrix.triplet }}
          path: dist/t2d_server.tar.gz*
          if-no-files-found: warn
      - name: Build Docker image (Linux only)
        if: runner.os == 'Linux'
        run: |
          docker build -t t2d/server:ci .
          docker image ls t2d/server:ci

  coverage:
    name: Coverage (Linux)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0
      - name: Install deps
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler libprotobuf-dev cmake g++ lcov ninja-build
      - name: Configure (Debug + coverage)
        run: cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DT2D_BUILD_TESTS=ON -DT2D_ENABLE_COVERAGE=ON -DT2D_BUILD_CLIENT=ON -G Ninja
      - name: Build
        run: cmake --build build -- -j4
      - name: Run tests (generate coverage)
        working-directory: build
        run: ctest --output-on-failure
      - name: Capture lcov
        run: |
          lcov --capture --directory build --output-file coverage.info
          lcov --remove coverage.info '/usr/*' 'third_party/*' --output-file coverage.info || true
          lcov --list coverage.info
      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-lcov
          path: coverage.info

  verify-dependencies:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Verify dependency manifest
        run: |
          set -e
          declare -A SUBS
          while read -r sha path rest; do
            clean_sha=${sha#-}; clean_sha=${clean_sha#+}; clean_sha=${clean_sha%%-*}
            SUBS["$path"]=$clean_sha
          done < <(git submodule status)
          missing=0
          while IFS= read -r line; do
            [[ $line == '|'*'|'* ]] || continue
            if echo "$line" | grep -qi '| *Name *|'; then continue; fi
            if echo "$line" | grep -Eq '^\|[- ]+\|'; then continue; fi
            IFS='|' read -r _ name path ref sha rest <<<"$line" || true
            name=$(echo "$name" | xargs); path=$(echo "$path" | xargs); sha=$(echo "$sha" | xargs)
            [[ -z $name || -z $path || -z $sha ]] && continue
            want=${sha,,}
            have=${SUBS[$path]:-}
            if [[ -z $have ]]; then
              echo "Mismatch: $name $path missing in submodule status" >&2
              missing=1; continue
            fi
            if [[ $have != $want ]]; then
              echo "Mismatch: $name $path sha expected $want got $have" >&2
              missing=1
            fi
          done < DEPENDENCIES.md
          if [[ $missing -ne 0 ]]; then exit 1; fi
          echo "Dependency manifest OK"
